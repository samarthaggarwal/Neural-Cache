# -*- coding: utf-8 -*-
"""alex2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/147HMs1ju33G-xlfD6X2N-H6KfmlE5_Oq
"""

!git clone https://github.com/Mayurji/Image-Classification-PyTorch.git

!mv Image-Classification-PyTorch/* .

!pip install -r requirements.txt

!python main.py --model=alexnet --model_save=True --checkpoint=True



import torch
import torch.optim as optim
from AlexNet import AlexNet

def optimizer_to(optim, device):
    for param in optim.state.values():
        # Not sure there are any global tensors in the state dict
        if isinstance(param, torch.Tensor):
            param.data = param.data.to(device)
            if param._grad is not None:
                param._grad.data = param._grad.data.to(device)
        elif isinstance(param, dict):
            for subparam in param.values():
                if isinstance(subparam, torch.Tensor):
                    subparam.data = subparam.data.to(device)
                    if subparam._grad is not None:
                        subparam._grad.data = subparam._grad.data.to(device)

device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
model=AlexNet(3, 10)
optimizer = optim.Adam(model.parameters(), 0.001)
checkpoint = torch.load('/content/drive/MyDrive/models3/model_e2.npy')
model.load_state_dict(checkpoint['model_state_dict'])
optimizer.load_state_dict(checkpoint['optimizer_state_dict'])  # load trained model and retrain it
#optimizer.param_groups[0]['lr'] = .0001 #change learning rate

optimizer_to(optimizer,device)
print(optimizer.param_groups[0]['lr'])
model.to(device)

import torchvision
from torchvision import transforms
from PIL import Image

# img = Image.open('/frame_camera_6.png')
# trans=transforms.ToTensor()
# img=trans(img)

transform = transforms.Compose([transforms.ToTensor(), transforms.Resize((224, 224)),
                        transforms.RandomHorizontalFlip(), transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])])

train_dataset = torchvision.datasets.CIFAR10(root='./data', train=True,
                                                        transform = transform,
                                                        download=True)
test_dataset = torchvision.datasets.CIFAR10(root='./data', train=False,
                                    transform = transform,
                                    download=True)

train_dataloader = torch.utils.data.DataLoader(dataset = train_dataset,
                                        batch_size=1,
                                        shuffle=True)
test_dataloader = torch.utils.data.DataLoader(dataset = test_dataset,
                                                        batch_size=1,
                                                        shuffle=True)
img=[]
cnt=0
for i,c in train_dataloader:
  img.append(i)
  cnt+=1
  if cnt > 3:
    break
out=model(img[0].to(device))
#print(out)

print(len(model.cache))
print(len(model.cache[0]))
print(len(model.cache[0][0]))

model.eval()
#model.train()
out=model(img[0].to(device))
print("--")
out=model(img[0].to(device))
print("--")
out=model(img[1].to(device))
print("--")
out=model(img[2].to(device))
print("--")
out=model(img[0].to(device))
print("--")

